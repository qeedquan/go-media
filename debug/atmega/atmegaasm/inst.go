package atmegaasm

import (
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
)

var (
	ErrShortInst = errors.New("short instruction")
)

type Mode uint32

const (
	IMP Mode = iota + 1
	IMM
	RIM
	RDS
	RDT
	DIL
	DIPIL
	DIPIOL
	DIS
	DIPIOS
	IOD
	DPA
	RPA
)

type Inst struct {
	Op         Op
	Enc        uint32
	Len        int
	Mode       Mode
	Rd, Rr, Ri uint8
	Addr       uint32
	Val        uint32
	Rel        int32
}

func rdt(op Op, src []byte) (Op, Mode, uint8, uint8) {
	rr := (src[0] & 0x0f) | (src[1]&0x2)<<3
	rd := (src[0]&0xf0)>>4 | (src[1]&0x1)<<4
	return op, RDT, rr, rd
}

func rdi(op Op, src []byte) (Op, Mode, uint8, uint32) {
	rd := 16 + (src[0]&0xf0)>>4
	val := uint32(src[0]&0xf) | uint32(src[1]&0xf)<<4
	return op, RIM, rd, val
}

func rdiw(op Op, src []byte) (Op, Mode, uint8, uint32) {
	rd := 24 + (src[0]>>3)&0x6
	val := uint32(src[0]&0xf) | uint32(src[0]&0xc0)>>2
	return op, RIM, rd, val
}

func br1(op Op, src []byte) (Op, Mode, int32) {
	val := int(src[0]&0xf8)>>3 | int(src[1]&0x3)<<5
	return op, RPA, sload(val, 7) << 1
}

func ind(op Op, mode Mode, ri uint8, src []byte) (Op, Mode, uint8, uint8, int32) {
	rd := (src[0]&0xf0)>>4 | (src[1]&0x1)<<4
	rel := int32(0)
	switch mode {
	case DIPIOL, DIPIOS:
		rel = int32(src[0]&0x7 | (src[1]&0xc)<<1 | src[1]&0x20)
	}

	return op, mode, rd, ri, rel
}

func rjc(src []byte) (op Op, enc uint32, len_ int, mode Mode, addr uint32, err error) {
	if len(src) < 4 {
		err = ErrShortInst
		return
	}
	op = JMP
	if src[0]&0x3 != 0 {
		op = CALL
	}
	enc = binary.LittleEndian.Uint32(src)
	len_ = 4
	mode = DPA
	addr = (enc&0xffff0000)>>16 | (enc&0x1)<<16 | (enc&0x1f0)<<17
	addr <<= 1
	return
}

func bit(op Op, src []byte) (Op, Mode, uint8, uint32) {
	rd := (src[0]>>4)&0xf | (src[1]&0x1)<<4
	val := uint32(src[0] & 0x7)
	return op, RIM, rd, val
}

func sload(val, bits int) int32 {
	mask := 1 << (bits - 1)
	return int32((val & (mask - 1)) - (val & mask))
}

func Decode(src []byte) (Inst, error) {
	if len(src) < 2 {
		return Inst{}, ErrShortInst
	}

	var rd, rr, ri uint8
	var addr, val uint32
	var rel int32
	var err error
	op := UNK
	enc := uint32(binary.LittleEndian.Uint16(src))
	len_ := 2
	mode := Mode(0)
	switch src[1] {
	case 0x00:
		if src[0] == 0 {
			op, mode = NOP, IMP
		}

	case 0x01:
		op, mode = MOVW, RDT
		rd = ((src[0] >> 4) & 0xf) << 1
		rr = (src[0] & 0xf) << 1

	case 0x02:
		op, mode, rr, rd = rdt(MULS, src)

	case 0x03:

	case 0x04, 0x05, 0x06, 0x07:
		op, mode, rr, rd = rdt(CPC, src)

	case 0x08, 0x09, 0x0a, 0x0b:
		op, mode, rr, rd = rdt(SBC, src)

	case 0x0c, 0x0d, 0x0e, 0x0f:
		op, mode, rr, rd = rdt(ADD, src)

	case 0x10, 0x11, 0x12, 0x13:
		op, mode, rr, rd = rdt(CPSE, src)

	case 0x14, 0x15, 0x16, 0x17:
		op, mode, rr, rd = rdt(CP, src)

	case 0x18, 0x19, 0x1a, 0x1b:
		op, mode, rr, rd = rdt(SUB, src)

	case 0x1c, 0x1d, 0x1e, 0x1f:
		op, mode, rr, rd = rdt(ADC, src)

	case 0x20, 0x21, 0x22, 0x23:
		op, mode, rr, rd = rdt(AND, src)

	case 0x24, 0x25, 0x26, 0x27:
		op, mode, rr, rd = rdt(EOR, src)

	case 0x28, 0x29, 0x2a, 0x2b:
		op, mode, rr, rd = rdt(OR, src)

	case 0x2c, 0x2d, 0x2e, 0x2f:
		op, mode, rr, rd = rdt(MOV, src)

	case 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
		0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3f:
		op, mode, rd, val = rdi(CPI, src)

	case 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f:
		op, mode, rd, val = rdi(SBCI, src)

	case 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
		0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f:
		op, mode, rd, val = rdi(SUBI, src)

	case 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f:
		op, mode, rd, val = rdi(ORI, src)

	case 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f:
		op, mode, rd, val = rdi(ANDI, src)

	case 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
		0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
		0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
		0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf:

		ri = 1
		if src[0]&0xf < 0x8 {
			ri = 2
		}
		switch src[1] {
		case 0x80, 0x81, 0x82, 0x83:
			op, mode = LD, DIL
			xop, xmode := LDD, DIPIOL
			if src[1] >= 0x82 {
				op, mode = ST, DIS
				xop, xmode = STD, DIPIOS
			}

			switch src[0] & 0xf {
			case 0x0, 0x8:
			default:
				op = xop
				mode = xmode
			}

		default:
			op, mode = LDD, DIPIOL
			if src[1]&0x2 != 0 {
				op, mode = STD, DIPIOS
			}
		}
		op, mode, rd, ri, rel = ind(op, mode, ri, src)

	case 0x90, 0x91, 0x92, 0x93:
		switch i := src[0] & 0xf; {
		case 0x4 <= i && i <= 0x7 && src[1] < 0x92:
			op = LPM
			if i >= 0x6 {
				op = ELPM
			}
			mode = DIL
			if i&0x1 != 0 {
				mode = DIPIL
			}
			ri = 2

		case i == 0xf:
			op, mode = POP, RDS
			if src[1] >= 0x92 {
				op = PUSH
			}
		}

		rd = (src[0] >> 4) & 0xf
		if src[1]&0x1 != 0 {
			rd += 16
		}

	case 0x94:
		if src[0]&0xc == 0xc {
			op, enc, len_, mode, addr, err = rjc(src)
			break
		}

		switch src[0] {
		case 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
			0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0:
			op, mode, rd = COM, RDS, (src[0]>>4)&0xf

		case 0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
			0x81, 0x91, 0xa1, 0xb1, 0xc1, 0xd1, 0xe1, 0xf1:
			op, mode, rd = NEG, RDS, (src[0]>>4)&0xf

		case 0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
			0x82, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2:
			op, mode, rd = SWAP, RDS, (src[0]>>4)&0xf

		case 0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
			0x83, 0x93, 0xa3, 0xb3, 0xc3, 0xd3, 0xe3, 0xf3:
			op, mode, rd = INC, RDS, (src[0]>>4)&0xf

		case 0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
			0x85, 0x95, 0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5:
			op, mode, rd = ASR, RDS, (src[0]>>4)&0xf

		case 0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
			0x86, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6:
			op, mode, rd = LSR, RDS, (src[0]>>4)&0xf

		case 0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
			0x87, 0x97, 0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7:
			op, mode, rd = ROR, RDS, (src[0]>>4)&0xf

		case 0x0a, 0x1a, 0x2a, 0x3a, 0x4a, 0x5a, 0x6a, 0x7a,
			0x8a, 0x9a, 0xaa, 0xba, 0xca, 0xda, 0xea, 0xfa:
			op, mode, rd = DEC, RDS, (src[0]>>4)&0xf

		case 0x08:
			op, mode = SEC, IMP

		case 0x09:
			op, mode = IJMP, IMP

		case 0x18:
			op, mode = SEZ, IMP

		case 0x19:
			op, mode = EIJMP, IMP

		case 0x28:
			op, mode = SEN, IMP

		case 0x38:
			op, mode = SEV, IMP

		case 0x48:
			op, mode = SES, IMP

		case 0x58:
			op, mode = SEH, IMP

		case 0x68:
			op, mode = SET, IMP

		case 0x78:
			op, mode = SEI, IMP

		case 0x88:
			op, mode = CLC, IMP

		case 0x98:
			op, mode = CLZ, IMP

		case 0xa8:
			op, mode = CLN, IMP

		case 0xb8:
			op, mode = CLV, IMP

		case 0xc8:
			op, mode = CLS, IMP

		case 0xd8:
			op, mode = CLH, IMP

		case 0xe8:
			op, mode = CLT, IMP

		case 0xf8:
			op, mode = CLI, IMP
		}

	case 0x95:
		if src[0]&0xc == 0xc {
			op, enc, len_, mode, addr, err = rjc(src)
			break
		}

		switch src[0] {
		case 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
			0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0:
			op, mode, rd = COM, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
			0x81, 0x91, 0xa1, 0xb1, 0xc1, 0xd1, 0xe1, 0xf1:
			op, mode, rd = NEG, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
			0x82, 0x92, 0xa2, 0xb2, 0xc2, 0xd2, 0xe2, 0xf2:
			op, mode, rd = SWAP, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
			0x83, 0x93, 0xa3, 0xb3, 0xc3, 0xd3, 0xe3, 0xf3:
			op, mode, rd = INC, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
			0x85, 0x95, 0xa5, 0xb5, 0xc5, 0xd5, 0xe5, 0xf5:
			op, mode, rd = ASR, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
			0x86, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6:
			op, mode, rd = LSR, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
			0x87, 0x97, 0xa7, 0xb7, 0xc7, 0xd7, 0xe7, 0xf7:
			op, mode, rd = ROR, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x0a, 0x1a, 0x2a, 0x3a, 0x4a, 0x5a, 0x6a, 0x7a,
			0x8a, 0x9a, 0xaa, 0xba, 0xca, 0xda, 0xea, 0xfa:
			op, mode, rd = DEC, RDS, (src[0]>>4)&0xf
			rd += 16

		case 0x08:
			op, mode = RET, IMP

		case 0x18:
			op, mode = RETI, IMP

		case 0x09:
			op, mode = ICALL, IMP

		case 0x19:
			op, mode = EICALL, IMP

		case 0x88:
			op, mode = SLEEP, IMP

		case 0x98:
			op, mode = BREAK, IMP

		case 0xa8:
			op, mode = WDR, IMP

		case 0xc8:
			op, mode = LPM, IMP

		case 0xd8:
			op, mode = ELPM, IMP

		case 0xe8, 0xf8:
			op, mode = SPM, IMP
		}

	case 0x96:
		op, mode, rd, val = rdiw(ADIW, src)

	case 0x97:
		op, mode, rd, val = rdiw(SBIW, src)

	case 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf:
		op = OUT
		mode = IOD
		addr = (enc & 0xf) | (enc&0x600)>>5
		rr = uint8((enc >> 4) & 0x1f)

	case 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
		0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf:
		op, mode = RJMP, RPA
		rel = sload(int(enc), 12) << 1

	case 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
		0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf:
		op, mode = RCALL, RPA
		rel = sload(int(enc), 12) << 1

	case 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
		0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef:
		op, mode, rd, val = rdi(LDI, src)

	case 0xf0, 0xf1, 0xf2, 0xf3:
		switch src[0] & 0x7 {
		case 0x0:
			op, mode, rel = br1(BRCS, src)
		case 0x1:
			op, mode, rel = br1(BREQ, src)
		case 0x2:
			op, mode, rel = br1(BRMI, src)
		case 0x3:
			op, mode, rel = br1(BRVS, src)
		case 0x4:
			op, mode, rel = br1(BRLT, src)
		case 0x5:
			op, mode, rel = br1(BRHS, src)
		case 0x6:
			op, mode, rel = br1(BRTS, src)
		case 0x7:
			op, mode, rel = br1(BRIE, src)
		}

	case 0xf4, 0xf5, 0xf6, 0xf7:
		switch src[0] & 0x7 {
		case 0x0:
			op, mode, rel = br1(BRCC, src)
		case 0x1:
			op, mode, rel = br1(BRNE, src)
		case 0x2:
			op, mode, rel = br1(BRPL, src)
		case 0x3:
			op, mode, rel = br1(BRVC, src)
		case 0x4:
			op, mode, rel = br1(BRGE, src)
		case 0x5:
			op, mode, rel = br1(BRHC, src)
		case 0x6:
			op, mode, rel = br1(BRTC, src)
		case 0x7:
			op, mode, rel = br1(BRID, src)
		}

	case 0xf8, 0xf9:
		op, mode, rd, val = bit(BLD, src)

	case 0xfa, 0xfb:
		op, mode, rd, val = bit(BST, src)

	case 0xfc, 0xfd:
		op, mode, rd, val = bit(SBRC, src)

	case 0xfe, 0xff:
		op, mode, rd, val = bit(SBRS, src)
	}

	return Inst{
		Op:   op,
		Enc:  enc,
		Len:  len_,
		Mode: mode,
		Rd:   rd,
		Rr:   rr,
		Ri:   ri,
		Addr: addr,
		Val:  val,
		Rel:  rel,
	}, err
}

func (i Inst) String() string {
	op := strings.ToLower(i.Op.String())
	args := ""
	switch i.Mode {
	case IMM:
		args = fmt.Sprintf("%d", i.Val)
	case RIM:
		args = fmt.Sprintf("r%d, %#02x", i.Rd, i.Val)
	case RDS:
		args = fmt.Sprintf("r%d", i.Rd)
	case RDT:
		args = fmt.Sprintf("r%d, r%d", i.Rd, i.Rr)
	case IOD:
		args = fmt.Sprintf("%#x, r%d", i.Addr, i.Rr)
	case DIL:
		args = fmt.Sprintf("r%d, %c", i.Rd, 'X'+i.Ri)
	case DIPIL:
		args = fmt.Sprintf("r%d, %c+", i.Rd, 'X'+i.Ri)
	case DIPIOL:
		args = fmt.Sprintf("r%d, %c+%d", i.Rd, 'X'+i.Ri, i.Rel)
	case DIS:
		args = fmt.Sprintf("%c, r%d", 'X'+i.Ri, i.Rd)
	case DIPIOS:
		args = fmt.Sprintf("%c+%d, r%d", 'X'+i.Ri, i.Rel, i.Rd)
	case DPA:
		args = fmt.Sprintf("%#x", i.Addr)
	case RPA:
		args = fmt.Sprintf(".%+d", i.Rel)
	}
	return fmt.Sprintf("%-12s %s", op, args)
}
